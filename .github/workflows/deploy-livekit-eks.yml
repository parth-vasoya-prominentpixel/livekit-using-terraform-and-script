name: LiveKit EKS Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - uat
          - prod
      step:
        description: 'Deployment step'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - infrastructure
          - load-balancer
          - livekit
          - destroy

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: 1.10.3
  KUBECTL_VERSION: v1.32.0
  HELM_VERSION: v3.16.3

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    name: Deploy LiveKit EKS
    runs-on: ubuntu-latest
    if: ${{ inputs.step != 'destroy' }}
    environment: 
      name: ${{ inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: GitHubActions-LiveKit-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Deploy Infrastructure
        if: ${{ inputs.step == 'all' || inputs.step == 'infrastructure' }}
        working-directory: resources
        run: |
          echo "üöÄ Deploying EKS Infrastructure"
          
          # Initialize Terraform
          terraform init -backend-config="../environments/livekit-poc/${{ env.AWS_REGION }}/${{ inputs.environment }}/backend.tfvars"
          
          # Validate configuration
          terraform validate
          
          # Apply infrastructure
          terraform apply \
            -var-file="../environments/livekit-poc/${{ env.AWS_REGION }}/${{ inputs.environment }}/inputs.tfvars" \
            -var="deployment_role_arn=${{ secrets.DEPLOYMENT_ROLE_ARN }}" \
            -auto-approve
          
          echo "‚úÖ Infrastructure deployed successfully"

      - name: Configure kubectl
        if: ${{ inputs.step == 'all' || inputs.step == 'load-balancer' || inputs.step == 'livekit' }}
        working-directory: resources
        run: |
          echo "ÔøΩ  Configuring kubectl"
          CLUSTER_NAME=$(terraform output -raw cluster_name)
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name "$CLUSTER_NAME"
          kubectl get nodes
          echo "‚úÖ kubectl configured"

      - name: Setup Load Balancer Controller
        if: ${{ inputs.step == 'all' || inputs.step == 'load-balancer' }}
        run: |
          echo "‚öñÔ∏è Setting up AWS Load Balancer Controller"
          
          # Get cluster info
          cd resources
          CLUSTER_NAME=$(terraform output -raw cluster_name)
          VPC_ID=$(terraform output -raw vpc_id)
          cd ..
          
          # Create IAM OIDC identity provider
          eksctl utils associate-iam-oidc-provider --region=${{ env.AWS_REGION }} --cluster=$CLUSTER_NAME --approve
          
          # Create service account
          eksctl create iamserviceaccount \
            --cluster=$CLUSTER_NAME \
            --namespace=kube-system \
            --name=aws-load-balancer-controller \
            --role-name AmazonEKSLoadBalancerControllerRole \
            --attach-policy-arn=arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:policy/AWSLoadBalancerControllerIAMPolicy \
            --approve \
            --region=${{ env.AWS_REGION }}
          
          # Install AWS Load Balancer Controller
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update
          
          helm install aws-load-balancer-controller eks/aws-load-balancer-controller \
            -n kube-system \
            --set clusterName=$CLUSTER_NAME \
            --set serviceAccount.create=false \
            --set serviceAccount.name=aws-load-balancer-controller \
            --set region=${{ env.AWS_REGION }} \
            --set vpcId=$VPC_ID
          
          # Wait for deployment
          kubectl wait --for=condition=available --timeout=300s deployment/aws-load-balancer-controller -n kube-system
          
          echo "‚úÖ Load Balancer Controller installed"

      - name: Deploy LiveKit
        if: ${{ inputs.step == 'all' || inputs.step == 'livekit' }}
        run: |
          echo "üé• Deploying LiveKit"
          
          # Get Redis endpoint
          cd resources
          REDIS_ENDPOINT=$(terraform output -raw redis_cluster_endpoint)
          cd ..
          
          # Create namespace
          kubectl create namespace livekit --dry-run=client -o yaml | kubectl apply -f -
          
          # Add LiveKit Helm repo
          helm repo add livekit https://livekit.github.io/charts
          helm repo update
          
          # Update Redis endpoint in values file
          sed -i "s|redis:.*|redis: \"$REDIS_ENDPOINT\"|g" livekit-values.yaml
          
          # Deploy LiveKit
          helm upgrade --install livekit livekit/livekit \
            -n livekit \
            -f livekit-values.yaml \
            --wait --timeout=10m
          
          # Show status
          kubectl get pods -n livekit
          kubectl get svc -n livekit
          kubectl get ingress -n livekit
          
          echo "‚úÖ LiveKit deployed successfully"

  destroy:
    name: Destroy Infrastructure
    runs-on: ubuntu-latest
    if: ${{ inputs.step == 'destroy' }}
    environment: 
      name: ${{ inputs.environment }}-destroy
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          role-session-name: GitHubActions-LiveKit-Destroy-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Cleanup Kubernetes Resources
        continue-on-error: true
        working-directory: resources
        run: |
          echo "üóëÔ∏è Cleaning up Kubernetes resources"
          
          # Initialize Terraform to get cluster info
          terraform init -backend-config="../environments/livekit-poc/${{ env.AWS_REGION }}/${{ inputs.environment }}/backend.tfvars"
          
          # Get cluster name if it exists
          CLUSTER_NAME=$(terraform output -raw cluster_name 2>/dev/null || echo "")
          
          if [ -n "$CLUSTER_NAME" ]; then
            echo "Found cluster: $CLUSTER_NAME"
            
            # Configure kubectl
            aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name "$CLUSTER_NAME" || true
            
            # Delete LiveKit namespace
            kubectl delete namespace livekit --ignore-not-found=true --timeout=60s || true
            
            # Delete Load Balancer Controller
            helm uninstall aws-load-balancer-controller -n kube-system || true
            
            echo "Kubernetes cleanup completed"
          else
            echo "No cluster found, skipping Kubernetes cleanup"
          fi

      - name: Destroy Infrastructure
        working-directory: resources
        run: |
          echo "üóëÔ∏è Destroying infrastructure"
          
          # Destroy with Terraform
          terraform destroy \
            -var-file="../environments/livekit-poc/${{ env.AWS_REGION }}/${{ inputs.environment }}/inputs.tfvars" \
            -var="deployment_role_arn=${{ secrets.DEPLOYMENT_ROLE_ARN }}" \
            -auto-approve
          
          echo "‚úÖ Infrastructure destroyed successfully"